struct Nintendo64DD : FloppyDisk {
  auto name() -> string override { return "Nintendo 64DD"; }
  auto extensions() -> vector<string> override { return {"n64dd", "ndd"}; }
  auto load(string location) -> bool override;
  auto save(string location) -> bool override;
  auto analyze(vector<u8>& rom) -> string;
  auto transform(array_view<u8> input) -> vector<u8>;
};

auto Nintendo64DD::load(string location) -> bool {
  vector<u8> input;
  if(directory::exists(location)) {
    append(input, {location, "program.disk"});
  } else if(file::exists(location)) {
    input = FloppyDisk::read(location);
  }
  if(!input) return false;

  this->location = location;
  this->manifest = analyze(input);
  auto document = BML::unserialize(manifest);
  if(!document) return false;

  pak = shared_pointer{new vfs::directory};
  pak->setAttribute("title", document["game/title"].string());
  pak->setAttribute("region", document["game/region"].string());
  pak->append("manifest.bml", manifest);

  array_view<u8> view{input};
  if(auto output = transform(view)) {
    pak->append("program.disk", output);
  }

  if(!pak) return false;

  Pak::load("program.disk", ".disk");

  return true;
}

auto Nintendo64DD::save(string location) -> bool {
  auto document = BML::unserialize(manifest);

  Pak::save("program.disk", ".disk");

  return true;
}

auto Nintendo64DD::analyze(vector<u8>& rom) -> string {
  string s;
  s += "game\n";
  s +={"  name: ",  Medium::name(location), "\n"};
  s +={"  title: ", Medium::name(location), "\n"};
  s += "  region:   NTSC\n";
  return s;
}

auto Nintendo64DD::transform(array_view<u8> input) -> vector<u8> {
  //only recognize base retail ndd for now
  if(input.size() != 0x3DEC800) return {};

  array_view<u8> dataFormat{input.data(), 0xE8};

  //ndd conv
  input.begin();
  vector<u8> output;
  output.resize(0x435B0C0, 0);

  u32 lba = 0;
  u32 type = dataFormat[5] & 0xF;
  u32 blockSizeTable[9] = {0x4D08, 0x47B8, 0x4510, 0x3FC0, 0x3A70, 0x3520, 0x2FD0, 0x2A80, 0x2530};
  u16 vzoneLbaTable[7][16] = {
    {0x0124, 0x0248, 0x035A, 0x047E, 0x05A2, 0x06B4, 0x07C6, 0x08D8, 0x09EA, 0x0AB6, 0x0B82, 0x0C94, 0x0DA6, 0x0EB8, 0x0FCA, 0x10DC},
    {0x0124, 0x0248, 0x035A, 0x046C, 0x057E, 0x06A2, 0x07C6, 0x08D8, 0x09EA, 0x0AFC, 0x0BC8, 0x0C94, 0x0DA6, 0x0EB8, 0x0FCA, 0x10DC},
    {0x0124, 0x0248, 0x035A, 0x046C, 0x057E, 0x0690, 0x07A2, 0x08C6, 0x09EA, 0x0AFC, 0x0C0E, 0x0CDA, 0x0DA6, 0x0EB8, 0x0FCA, 0x10DC},
    {0x0124, 0x0248, 0x035A, 0x046C, 0x057E, 0x0690, 0x07A2, 0x08B4, 0x09C6, 0x0AEA, 0x0C0E, 0x0D20, 0x0DEC, 0x0EB8, 0x0FCA, 0x10DC},
    {0x0124, 0x0248, 0x035A, 0x046C, 0x057E, 0x0690, 0x07A2, 0x08B4, 0x09C6, 0x0AD8, 0x0BEA, 0x0D0E, 0x0E32, 0x0EFE, 0x0FCA, 0x10DC},
    {0x0124, 0x0248, 0x035A, 0x046C, 0x057E, 0x0690, 0x07A2, 0x086E, 0x0980, 0x0A92, 0x0BA4, 0x0CB6, 0x0DC8, 0x0EEC, 0x1010, 0x10DC},
    {0x0124, 0x0248, 0x035A, 0x046C, 0x057E, 0x0690, 0x07A2, 0x086E, 0x093A, 0x0A4C, 0x0B5E, 0x0C70, 0x0D82, 0x0E94, 0x0FB8, 0x10DC}
  };
  u8 vzone2pzoneTable[7][16] = {
    {0x0, 0x1, 0x2, 0x9, 0x8, 0x3, 0x4, 0x5, 0x6, 0x7, 0xF, 0xE, 0xD, 0xC, 0xB, 0xA},
    {0x0, 0x1, 0x2, 0x3, 0xA, 0x9, 0x8, 0x4, 0x5, 0x6, 0x7, 0xF, 0xE, 0xD, 0xC, 0xB},
    {0x0, 0x1, 0x2, 0x3, 0x4, 0xB, 0xA, 0x9, 0x8, 0x5, 0x6, 0x7, 0xF, 0xE, 0xD, 0xC},
    {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0xC, 0xB, 0xA, 0x9, 0x8, 0x6, 0x7, 0xF, 0xE, 0xD},
    {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8, 0x7, 0xF, 0xE},
    {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8, 0xF},
    {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8}
  };
  u16 trackPhysicalTable[] = {0x000, 0x09E, 0x13C, 0x1D1, 0x266, 0x2FB, 0x390, 0x425,
                              0x091, 0x12F, 0x1C4, 0x259, 0x2EE, 0x383, 0x418, 0x48A};
  u32 vzone = 0;

  for (; lba < 0x10DC; lba++) {
    if (lba >= vzoneLbaTable[type][vzone]) vzone++;
    u32 pzoneCalc = vzone2pzoneTable[type][vzone];
    u32 headCalc = (pzoneCalc > 7) ? 1 : 0;

    u32 lba_vzone = lba;
    if (vzone > 0) lba_vzone -= vzoneLbaTable[type][vzone - 1];

    u32 trackStart = trackPhysicalTable[headCalc ? pzoneCalc - 8 : pzoneCalc];
    u32 trackCalc = trackPhysicalTable[pzoneCalc];
    if (headCalc) trackCalc -= (lba_vzone >> 1);
    else trackCalc += (lba_vzone >> 1);

    u32 defectOffset = 0;
    if (pzoneCalc > 0) defectOffset = dataFormat[8 + pzoneCalc - 1];
    u32 defectAmount = dataFormat[8 + pzoneCalc] - defectOffset;

    while ((defectAmount != 0) && ((dataFormat[0x20 + defectOffset] + trackStart) <= trackCalc)) {
      trackCalc++;
      defectOffset++;
      defectAmount--;
    }

    u32 blockCalc = ((lba & 3) == 0 || (lba & 3) == 3) ? 0 : 1;

    u32 startOffsetTable[16] = {0x0,0x5F15E0,0xB79D00,0x10801A0,0x1523720,0x1963D80,0x1D414C0,0x20BBCE0,
		                            0x23196E0,0x28A1E00,0x2DF5DC0,0x3299340,0x36D99A0,0x3AB70E0,0x3E31900,0x4149200};
    u32 offsetCalc = startOffsetTable[pzoneCalc];
    offsetCalc += (trackCalc - trackStart) * (blockSizeTable[headCalc ? pzoneCalc - 7 : pzoneCalc] * 2);
    offsetCalc += blockSizeTable[headCalc ? pzoneCalc - 7 : pzoneCalc] * blockCalc;

    for(u32 n : range(blockSizeTable[headCalc ? pzoneCalc - 7 : pzoneCalc]))
      output[offsetCalc + n] = input.read();
  }

  return output;
}
